buildscript {
    dependencies {
        classpath libs.tinyremapper
    }
}

plugins {
    id "com.dorongold.task-tree" version "2.1.0"
    id 'groovy'
    id 'maven-publish'
    alias libs.plugins.quilt.loom apply false
    id 'org.cadixdev.licenser' version '0.6.1'
    id 'io.github.groovymc.modsdotgroovy' version '1.1.1' apply false
    id 'io.github.p03w.machete' version '1.2.0' apply false
}

static String getGitCommit() {
    def proc = 'git rev-parse --short HEAD'.execute()
    proc.waitFor()
    return proc.exitValue()? "ERROR(${proc.exitValue()})" : proc.text.trim()
}

def topProject = project

configurations {
    janksonResolve
}

dependencies {
    janksonResolve libs.groovy.toml
}

allprojects {
    configurations.configureEach {
        resolutionStrategy.eachDependency { DependencyResolveDetails details ->
            if (details.requested.version == '<jankson-resolve>') {
                details.useVersion rootProject.configurations.janksonResolve.resolvedConfiguration.resolvedArtifacts.find {
                    it.moduleVersion.id.group == details.requested.group && it.moduleVersion.id.name == details.requested.name
                }.moduleVersion.id.version
            }
        }
    }
}

allprojects {
    apply plugin: 'org.cadixdev.licenser'

    configurations.configureEach {
        resolutionStrategy.eachDependency { DependencyResolveDetails details ->
            if (details.requested.module.with {it?.name == 'tiny-remapper' && it?.group == 'net.fabricmc'}) {
                details.useTarget libs.tinyremapper
            }
        }
    }

    repositories {
        maven {
            name = "Luke's Maven"
            url = 'https://maven.lukebemish.dev/releases'
        }
        maven {
            name = "TheModdingInquisition"
            url = 'https://maven.moddinginquisition.org/releases'
        }
        maven {
            name = 'ParchmentMC'
            url = 'https://maven.parchmentmc.org'
        }
    }

    license {
        header = topProject.file('../header.txt')
        exclude '**/package-info.java'
    }
}

subprojects.findAll { !(it.name in ['wrapper'])  }.each { p ->
    p.with {
        apply plugin: 'groovy'
        apply plugin: 'maven-publish'
        apply plugin: libs.plugins.quilt.loom.get().pluginId
        apply plugin: 'io.github.groovymc.modsdotgroovy'

        modsDotGroovy {
            dslVersion = '1.3.0'
            platform 'quilt'
        }

        dependencies {
            minecraft libs.minecraft
            mappings loom.layered() {
                officialMojangMappings()
                parchment("org.parchmentmc.data:parchment-${libs.versions.parchment.minecraft.get()}:${libs.versions.parchment.mappings.get()}@zip")
            }
            modCompileOnly libs.quilt.loader

            annotationProcessor libs.autoextension
            annotationProcessor libs.autoservice
            compileOnly libs.autoextension
            compileOnly libs.autoservice
        }

        jar {
            from(topProject.file("../LICENSE")) {
                rename { "${it}-${archivesBaseName}" }
            }
        }

        tasks.withType(JavaCompile).configureEach {
            it.options.encoding = "UTF-8"
            it.options.release = 17
        }

        java {
            sourceCompatibility = JavaVersion.VERSION_17
            targetCompatibility = JavaVersion.VERSION_17
            withSourcesJar()
        }

        processResources {
            inputs.property "version", version

            filesMatching('META-INF/groovy/') {
                expand "version": version
            }
        }

        tasks.withType(GroovyCompile) {
            groovyOptions.optimizationOptions.indy = true
            groovyOptions.optimizationOptions.groovydoc = true
            it.groovyOptions.javaAnnotationProcessing = true
            it.exclude('mods.groovy')
        }

        rootProject.groovydoc {
            source p.sourceSets.main.allSource
            exclude 'mods.groovy'
            exclude 'META-INF/'
        }

        p.tasks.groovydoc.enabled = false

        tasks.compileGroovy { t ->
            p.afterEvaluate {
                t.options.compilerArgs += [
                        "-Aautoextension.name=${p.archivesBaseName}",
                        "-Aautoextension.version=${version}"
                ]
            }
        }
    }
}

import net.fabricmc.loom.task.RemapJarTask

subprojects.findAll { !(it.name in ['wrapper', 'groovy'])  }.each { p ->
    p.with {
        dependencies {
            modImplementation libs.quilt.loader
            modImplementation libs.qsl
        }

        tasks.remapJar.with {
            it.addNestedDependencies = false
        }

        tasks.register("remapFullJar", RemapJarTask) {
            it.targetNamespace = "intermediary"
            it.inputFile = tasks.jar.archiveFile
            it.dependsOn tasks.jar
            it.archiveClassifier.set 'full'
            it.addNestedDependencies = true
        }

        configurations {
            fullJars {
                canBeConsumed = true
                canBeResolved = false
            }
        }

        artifacts {
            fullJars(remapFullJar.archiveFile) {
                builtBy remapFullJar
            }
        }
    }
}

subprojects.findAll { it.name in ['fatjar', 'groovy']  }.each { p ->
    p.with {
        apply plugin: 'io.github.p03w.machete'

        machete {
            json.enabled = false
            png.enabled = false
            xml.enabled = false
            lvtStriping.enabled = false
            sourceFileStriping.enabled = false
            ignoredTasks.add("jar")
            additionalTasks.add("remapJar")
        }
    }
}

repositories {
    mavenCentral()
}

configurations {
    groovydocInclude
}

dependencies {
    implementation libs.groovy

    groovydocInclude("io.github.groovymc.cgl:cgl-1.19.4:${libs.versions.cgl.get()}:sources") {
        transitive = false
    }
}

groovydoc {
    source zipTree(configurations.groovydocInclude.singleFile)
    use = true
    docTitle = "GroovyDuvet v${version} - API"
    link "https://docs.groovy-lang.org/${libs.versions.groovy.get()}/html/api/", 'groovy', 'org.apache.groovy', 'org.codehaus.groovy'
    //link "https://maven.quiltmc.org/repository/release/org/quiltmc/quilt-loader/${libs.versions.quilt.loader.get()}/quilt-loader-${libs.versions.quilt.loader.get()}-javadoc.jar/",
    //        'net.fabricmc', 'org.quiltmc.loader'
    //link "https://maven.quiltmc.org/repository/release/org/quiltmc/qsl/${libs.versions.qsl.get()}/qsl-${libs.versions.qsl.get()}-fat-javadoc.jar/",
    //        'org.quiltmc.qsl'

    exclude 'enhancedgroovy/'
}

task groovydocJar(type: Jar, dependsOn: groovydoc ) {
    classifier 'javadoc' // must use javadoc classifier to be able to deploy to Sonatype
    from groovydoc.destinationDir
}

tasks.build.dependsOn(tasks.groovydocJar)
tasks.jar.enabled = false
