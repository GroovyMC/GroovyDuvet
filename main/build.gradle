buildscript {
    dependencies {
        classpath libs.tinyremapper
    }
}

plugins {
    id 'groovy'
    id 'maven-publish'
    alias libs.plugins.quilt.loom apply false
    alias libs.plugins.quilt.licenser apply false
    alias libs.plugins.mdg.plugin apply false
    alias libs.plugins.machete apply false
    alias libs.plugins.simpleci
}

rootProject.ext.mavenLoginUser = (System.getenv('MAVEN_USER') ?: findProperty('inquisitionMavenUser')) ?: ''
rootProject.ext.mavenLoginPassword = (System.getenv('MAVEN_PASSWORD') ?: findProperty('inquisitionMavenPassword')) ?: ''

tasks.changelog {
    gitDir = rootProject.file('../')
    start = '2.1.1'
}

import org.eclipse.jgit.api.Git

versioning {
    fromTag.set('2.1.1')
}
final calculatedVersion = Git.open(rootProject.file("../")).withCloseable {
    versioning.calculateVersion(it) { cm, info -> }
}
project.ext.versionBasedReleaseType = calculatedVersion.alphaBeta.betaNumber != -1 ? 'beta' : (calculatedVersion.alphaBeta.alphaNumber != -1 ? 'alpha' : 'release')
allprojects { Project proj ->
    println("${proj.name} version: ${proj.version = calculatedVersion.toString()}")
}

allprojects {
    apply plugin: libs.plugins.quilt.licenser.get().pluginId

    license {
        rule rootProject.file('../header.txt')
        exclude '**/*.mcmeta'
    }
}

static String getGitCommit() {
    def proc = 'git rev-parse --short HEAD'.execute()
    proc.waitFor()
    return proc.exitValue()? "ERROR(${proc.exitValue()})" : proc.text.trim()
}

def topProject = project

configurations {
    jacksonResolve
}

dependencies {
    jacksonResolve libs.groovy.toml
}

allprojects {
    configurations.configureEach {
        resolutionStrategy.eachDependency { DependencyResolveDetails details ->
            if (details.requested.version == '<jackson-resolve>') {
                details.useVersion rootProject.configurations.jacksonResolve.resolvedConfiguration.resolvedArtifacts.find {
                    it.moduleVersion.id.group == details.requested.group && it.moduleVersion.id.name == details.requested.name
                }.moduleVersion.id.version
            }
        }
    }
}

allprojects {
    configurations.configureEach {
        resolutionStrategy.eachDependency { DependencyResolveDetails details ->
            if (details.requested.module.with {it?.name == 'tiny-remapper' && it?.group == 'net.fabricmc'}) {
                details.useTarget libs.tinyremapper
            }
        }
    }

    repositories {
        maven {
            name = "Luke's Maven"
            url = 'https://maven.lukebemish.dev/releases'
        }
        maven {
            name = "TheModdingInquisition"
            url = 'https://maven.moddinginquisition.org/releases'
        }
        maven {
            name = 'ParchmentMC'
            url = 'https://maven.parchmentmc.org'
        }
    }
}

subprojects.findAll { !(it.name in ['wrapper'])  }.each { p ->
    p.with {
        apply plugin: 'groovy'
        apply plugin: 'maven-publish'
        apply plugin: libs.plugins.quilt.loom.get().pluginId
        apply plugin: libs.plugins.mdg.plugin.get().pluginId

        modsDotGroovy {
            dslVersion = libs.versions.mdg.dsl.get()
            platform 'quilt'
        }

        dependencies {
            minecraft libs.minecraft
            mappings loom.layered() {
                officialMojangMappings()
                parchment("org.parchmentmc.data:parchment-${libs.versions.parchment.minecraft.get()}:${libs.versions.parchment.mappings.get()}@zip")
            }
            modCompileOnly libs.quilt.loader

            annotationProcessor libs.autoextension
            annotationProcessor libs.autoservice
            compileOnly libs.autoextension
            compileOnly libs.autoservice
        }

        jar {
            from(topProject.file("../LICENSE")) {
                rename { "${it}-${archivesBaseName}" }
            }
        }

        tasks.withType(JavaCompile).configureEach {
            it.options.encoding = "UTF-8"
            it.options.release = 17
        }

        java {
            sourceCompatibility = JavaVersion.VERSION_17
            targetCompatibility = JavaVersion.VERSION_17
            withSourcesJar()
        }

        processResources {
            inputs.property "version", version

            filesMatching('META-INF/groovy/') {
                expand "version": version
            }
        }

        tasks.withType(GroovyCompile) {
            groovyOptions.optimizationOptions.indy = true
            groovyOptions.optimizationOptions.groovydoc = true
            it.groovyOptions.javaAnnotationProcessing = true
            it.exclude('mods.groovy')
        }

        rootProject.groovydoc {
            source p.sourceSets.main.allSource
            exclude 'mods.groovy'
            exclude 'META-INF/'
        }

        p.tasks.groovydoc.enabled = false

        tasks.compileGroovy { t ->
            p.afterEvaluate {
                t.options.compilerArgs += [
                        "-Aautoextension.name=${p.archivesBaseName}",
                        "-Aautoextension.version=${version}"
                ]
            }
        }
    }
}

import net.fabricmc.loom.task.RemapJarTask

subprojects.findAll { !(it.name in ['wrapper', 'groovy'])  }.each { p ->
    p.with {
        dependencies {
            modImplementation libs.quilt.loader
            modImplementation libs.qsl
        }

        tasks.remapJar.with {
            it.addNestedDependencies = false
        }

        tasks.register("remapFullJar", RemapJarTask) {
            it.targetNamespace = "intermediary"
            it.inputFile = tasks.jar.archiveFile
            it.dependsOn tasks.jar
            it.archiveClassifier.set 'full'
            it.addNestedDependencies = true
        }

        configurations {
            fullJars {
                canBeConsumed = true
                canBeResolved = false
            }
        }

        artifacts {
            fullJars(remapFullJar.archiveFile) {
                builtBy remapFullJar
            }
        }
    }
}

subprojects.findAll { it.name in ['fatjar', 'groovy']  }.each { p ->
    p.with {
        apply plugin: libs.plugins.machete.get().pluginId

        machete {
            json.enabled = false
            png.enabled = false
            xml.enabled = false
            lvtStriping.enabled = false
            sourceFileStriping.enabled = false
            ignoredTasks.add("jar")
            additionalTasks.add("remapJar")
        }
    }
}

repositories {
    mavenCentral()
}

configurations {
    groovydocInclude
}

dependencies {
    implementation libs.groovy

    groovydocInclude("io.github.groovymc.cgl:cgl-1.19.4:${libs.versions.cgl.get()}:sources") {
        transitive = false
    }
}

groovydoc {
    source zipTree(configurations.groovydocInclude.singleFile)
    use = true
    docTitle = "GroovyDuvet v${version} - API"
    link "https://docs.groovy-lang.org/${libs.versions.groovy.get()}/html/api/", 'groovy', 'org.apache.groovy', 'org.codehaus.groovy'
    //link "https://maven.quiltmc.org/repository/release/org/quiltmc/quilt-loader/${libs.versions.quilt.loader.get()}/quilt-loader-${libs.versions.quilt.loader.get()}-javadoc.jar/",
    //        'net.fabricmc', 'org.quiltmc.loader'
    //link "https://maven.quiltmc.org/repository/release/org/quiltmc/qsl/${libs.versions.qsl.get()}/qsl-${libs.versions.qsl.get()}-fat-javadoc.jar/",
    //        'org.quiltmc.qsl'

    exclude 'enhancedgroovy/'
}

task groovydocJar(type: Jar, dependsOn: groovydoc ) {
    archiveClassifier.set 'javadoc'
    from groovydoc.destinationDir
}

tasks.build.dependsOn(tasks.groovydocJar)
tasks.jar.enabled = false
